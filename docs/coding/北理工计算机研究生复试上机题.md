---
title: 北理工计算机研究生复试上机题
date: 2020-2-26 11:26
tags: [技术文]
---

<CreateTime/>
<TagLinks />

::: tip
复试分两天：第一天上午是 英语听力（20 分钟，满分 10 分），上机（2 小时，满分 20 分）；下午英语口语面试（10 分钟，满分 10 分）；第二天上午专家综合面试（包含七选四的专业课测试，20 分钟，满分 60 分）。
:::

[参考经验贴 1](https://blog.csdn.net/wusiji8121/article/details/85229164)

[参考经验贴 2](https://blog.csdn.net/sr_19930829/article/details/50930167?depth_1-utm_source=distribute.pc_relevant_right.none-task&utm_source=distribute.pc_relevant_right.none-task)

[参考经验贴 3](https://blog.csdn.net/srg1011/article/details/88604093)

## stdc++.h 文件的使用

stdc++.h 中链接了所有的头文件，因此在练习环境中使用很方便。但是 VC 中并没有自带这个文件，所以我们要自己把它加到`include`里去。

我使用的是 XP 虚拟机，安装了 VC 做题。首先打开目录：`C:\Program Files\Microsoft Visual Studio\VC98\Include`，在目录下新建文件夹`bits`，然后进入新建的文件夹，新建文件`stdc++.h`，复制以下内容在新文件中：

```cpp
#ifndef _GLIBCXX_NO_ASSERT
#include <cassert>
#endif
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

#if __cplusplus >= 201103L
#include <ccomplex>
#include <cfenv>
#include <cinttypes>
#include <cstdalign>
#include <cstdbool>
#include <cstdint>
#include <ctgmath>
#include <cwchar>
#include <cwctype>
#endif

// C++
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>

#if __cplusplus >= 201103L
#include <array>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#endif
```

使用方式如下：

```cpp
#include <bits/stdc++.h>
```

## 2019 年

### 第一题

形如 aabbaaacaa 的字符串，可分为五个相同连续字母组成的碎片：'aa','bb','aaa','c','aa'，其中每个碎片只出现一次，即该字符串包含'aa','bb','aaa','c'四个碎片，且输出时按字典序排序。

样例：
输入|输出
:-:|:-:
a|a
aabbcccddaa|aa<br>bb<br>ccc<br>dd

代码：

```cpp
#include"string"
#include"iostream"
#include<algorithm>
#pragma warning(disable:4786)
#include<vector>

using namespace std;

int main() {
	string str; //输入的字符串
	cin >> str;
	vector<string> lst; //切分并排序后的字符串数组
	char pre; //储存前一个字符
	string temp = ""; //临时存放连续相同的字符组成的字符串
	vector<string> indi_lst; //去重后的字符串数组
	int is_has = 0; //用来判断是否在indi_lst已包含相同字符串
	for (int i = 0; i < str.size(); i ++) {
		if (i == 0) {
			pre = str[i];
			temp += pre;
			continue;
		}
		if (str[i] == pre) {
			temp += str[i];
		} else {
			pre = str[i];
			lst.push_back(temp);
			temp = "";
			temp += pre;
		}
	}
	lst.push_back(temp);
	sort(lst.begin(), lst.end());
	for (i = 0; i < lst.size(); i ++) {
		if (i == 0) {
			indi_lst.push_back(lst[i]);
			continue;
		}
		for (int j = 0; j < indi_lst.size(); j ++) {
			if (lst[i] == indi_lst[j]) {
				is_has = 1;
			}
		}
		if (is_has == 0) {
			indi_lst.push_back(lst[i]);
		} else {
			is_has = 0;
			continue;
		}
	}
	for (i = 0; i < indi_lst.size(); i ++) {
		cout << indi_lst[i] << endl;
	}
	return 0;
}
```

思考:

个人觉得本题的难点主要是去重。网上的[原帖](https://blog.csdn.net/qq_37513086/article/details/88558773)给出的去重逻辑是这样的：

```cpp
for(int i = 0; i < lst.size(); i++){
		for(int j = i+1; j < lst.size(); j++){
			if(lst[i] == lst[j])
				lst.erase(lst.begin()+i);
		}
	}
```

这样写有一个问题，当重复字符串大于 2 个时，就错了，这种方法只会去掉一次重复。

我在上方`代码`部分给出的方式比较笨，但没有错误，下面我们利用`map`对代码进行优化，将去重部分的代码改为：

_TODO_

### 第二题

求哈夫曼树的最短带权路径长度

输入：第一行为权值个数 n，第二行是 n 个权值

输出：最短带权路径长度

样例：
输入|输出
:-:|:-:
4<br>2,4,5,7|35
4<br>1,1,1,1|8

代码：
